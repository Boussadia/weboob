#!/usr/bin/env python
# -*- coding: utf-8 -*-
# vim: ft=python et softtabstop=4 cinoptions=4 shiftwidth=4 ts=4 ai

"""
Copyright(C) 2010  Romain Bignon

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

"""

from email.mime.text import MIMEText
from smtplib import SMTP
from email.Header import Header
from email.Utils import parseaddr, formataddr
import time
import sys

from weboob import Weboob
from weboob.capabilities.messages import ICapMessages
from weboob.tools.application import BaseApplication

class Application(BaseApplication):
    APPNAME = 'mail'
    CONFIG = {'interval':  15,
              'domain':    'weboob.example.org',
              'recipient': 'weboob@example.org',
              'smtp':      'localhost'}

    def main(self, argv):
        self.load_config()
        if not self.myconfig:
            print >>sys.stderr, "Error: %s is not configured yet. Please call 'weboob2mail -c'" % argv[0]
            print >>sys.stderr, "Also, you need to use 'weboobcfg' to set backend configs"
            return -1

        self.weboob.load_modules(ICapMessages, backends=self.config.getbackends())

        self.weboob.schedule(self.myconfig['interval'], self.process)
        self.weboob.loop()

    def process(self):
        for name, backend in self.weboob.iter_backends():
            for message in backend.iter_new_messages():
                self.send_email(name, message)

    def send_email(self, backend_name, mail):
        domain = self.myconfig['domain']
        recipient = self.myconfig['recipient']

        reply_id = ''
        if mail.get_reply_id():
            reply_id = u'%s.%s@%s' % (backend_name, mail.get_full_reply_id(), domain)
        subject = u'%s%s' % ((reply_id) and 'Re: ' or '', mail.get_title())
        sender = u'%s <%s.%s.%s@%s>' % (mail.get_from(), backend_name, mail.get_thread_id(), mail.get_id(), domain)

        # assume that get_date() returns an UTC datetime
        date = time.strftime('%a, %d %b %Y %H:%M:%S +0000', mail.get_date().timetuple())
        msg_id = u'%s.%s@%s' % (backend_name, mail.get_full_id(), domain)
        body = mail.get_content()

        if mail.get_signature():
            body += u'\n\n-- \n'
            body += mail.get_signature()

        # Header class is smart enough to try US-ASCII, then the charset we
        # provide, then fall back to UTF-8.
        header_charset = 'ISO-8859-1'

        # We must choose the body charset manually
        for body_charset in 'US-ASCII', 'ISO-8859-1', 'UTF-8':
            try:
                body.encode(body_charset)
            except UnicodeError:
                pass
            else:
                break

        # Split real name (which is optional) and email address parts
        sender_name, sender_addr = parseaddr(sender)
        recipient_name, recipient_addr = parseaddr(recipient)

        # We must always pass Unicode strings to Header, otherwise it will
        # use RFC 2047 encoding even on plain ASCII strings.
        sender_name = str(Header(unicode(sender_name), header_charset))
        recipient_name = str(Header(unicode(recipient_name), header_charset))

        # Make sure email addresses do not contain non-ASCII characters
        sender_addr = sender_addr.encode('ascii')
        recipient_addr = recipient_addr.encode('ascii')

        # Create the message ('plain' stands for Content-Type: text/plain)
        msg = MIMEText(body.encode(body_charset), 'plain', body_charset)
        msg['From'] = formataddr((sender_name, sender_addr))
        msg['To'] = formataddr((recipient_name, recipient_addr))
        msg['Subject'] = Header(unicode(subject), header_charset)
        msg['Message-Id'] = msg_id
        msg['Date'] = date
        if reply_id:
            msg['In-Reply-To'] = reply_id

        # Send the message via SMTP to localhost:25
        smtp = SMTP(self.myconfig['smtp'])
        smtp.sendmail(sender, recipient, msg.as_string())
        smtp.quit()

        return msg['Message-Id']

if __name__ == '__main__':
    Application.run()
